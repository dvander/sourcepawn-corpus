/* Plugin Template generated by Pawn Studio */
#pragma semicolon 1

#include <sourcemod>
#include <sdktools>
#include <sdkhooks>

public Plugin:myinfo = 
{
	name = "Set Defuse Time",
	author = "LittleKu(L.K)",
	description = "This plugin can set the defuse time for the specify player",
	version = "1.0",
	url = "http://www.cnblogs.com/littleku/"
}

enum 
{
	HasKit = 0,
	WithoutKit,
};

new gBombEntity = -1;
new gbBombUseHook = 0;

new gArrPlayerDefuseTime[MAXPLAYERS][2];

/****Member Offsets****/
new m_bBombTicking;
new m_flC4Blow;
new m_bInNoDefuseArea;
new m_bStartDefuse;
new m_bHasDefuser;
new m_flDefuseLength;
new m_flDefuseCountDown;

public OnPluginStart()
{
	HookEvent("bomb_planted", Event_BombPlantedPost);
	HookEvent("round_start", Event_BombPlantedPost);
}

public OnMapStart()
{
	GetDataOffset();
}

public APLRes:AskPluginLoad2(Handle:myself, bool:late, String:error[], err_max)
{
	CreateNative("SetClientDefuseTime", Native_SetClientDefuseTime);
	return APLRes_Success;
}

//native SetClientDefuseTime(client, time1, time2);
public Native_SetClientDefuseTime(Handle:plugin, numParams)
{
	new client = GetNativeCell(1);
	new time1 = GetNativeCell(2);//with kit
	new time2 = GetNativeCell(3);//without kit
	
	if (client <= 0 || client > MAXPLAYERS)
		return ThrowNativeError(SP_ERROR_ARRAY_BOUNDS, "Index out of bounds %d", client);
	else if (!IsClientInGame(client))
		return ThrowNativeError(SP_ERROR_INDEX, "Invalid index %d", client);
	
	gArrPlayerDefuseTime[client][HasKit] = time1;
	gArrPlayerDefuseTime[client][WithoutKit] = time2;
	
	return 1;
}

public OnClientConnected(client)
{
	gArrPlayerDefuseTime[client][HasKit] = 5;
	gArrPlayerDefuseTime[client][WithoutKit] = 10;
}

public Event_BombPlantedPost(Handle:event, const String:name[], bool:dontBroadcast)
{
	if(StrEqual(name, "bomb_planted"))
	{
		gBombEntity= FindEntityByClassname(gBombEntity, "planted_c4");
		
		SDKHook(gBombEntity, SDKHook_Use, CPlantedC4Use);
		SDKHook(gBombEntity, SDKHook_UsePost, CPlantedC4UsePost);
	}
	else
	{
		gBombEntity = -1;
	}
}

public Action:CPlantedC4Use(entity, activator, caller, UseType:type, Float:value)
{
	if ((GetEntData(entity, m_bBombTicking, 1) & (1<<0))		/*m_bBombTicking*/
	&& GetGameTime() <= GetEntDataFloat(entity, m_flC4Blow)		/*m_flC4Blow*/ 
	&& GetEntProp(activator, Prop_Data, "m_iTeamNum") == 3 
	&& !(GetEntData(activator, m_bInNoDefuseArea, 1) & (1<<0))	/*m_bInNoDefuseArea*/ 
	&& !(GetEntData(entity, m_bStartDefuse, 1) & (1<<0)))					/*m_bStartDefuse*/
	{
		gbBombUseHook = 1;
	}
	return Plugin_Continue;
}

public CPlantedC4UsePost(entity, activator, caller, UseType:type, Float:value)
{
	if (gbBombUseHook)
	{
		new flDefuseLength = (GetEntData(activator, m_bHasDefuser, 1) & (1<<0))					/*m_bHasDefuser */
		? gArrPlayerDefuseTime[activator][HasKit] : gArrPlayerDefuseTime[activator][WithoutKit];
		SetEntDataFloat(entity, m_flDefuseLength, float(flDefuseLength));						/*m_flDefuseLength*/
		SetEntDataFloat(entity, m_flDefuseCountDown, GetGameTime() + float(flDefuseLength));	/*m_flDefuseCountDown*/
		SetEntProp(activator, Prop_Send, "m_iProgressBarDuration", flDefuseLength);
		
		gbBombUseHook = 0;
	}
}

stock Handle:GetBombTimeConf()
{
	static Handle:hGameConf = INVALID_HANDLE;
	if (hGameConf == INVALID_HANDLE)
		hGameConf = LoadGameConfigFile("bombtime.games");
	return hGameConf;
}

stock GetDataOffset()
{
	m_bBombTicking = GameConfGetOffset(GetBombTimeConf(), "m_bBombTicking");
	m_flC4Blow = GameConfGetOffset(GetBombTimeConf(), "m_flC4Blow");
	m_bInNoDefuseArea = GameConfGetOffset(GetBombTimeConf(), "m_bInNoDefuseArea");
	m_bStartDefuse = GameConfGetOffset(GetBombTimeConf(), "m_bStartDefuse");
	m_bHasDefuser = GameConfGetOffset(GetBombTimeConf(), "m_bHasDefuser");
	m_flDefuseLength = GameConfGetOffset(GetBombTimeConf(), "m_flDefuseLength");
	m_flDefuseCountDown = GameConfGetOffset(GetBombTimeConf(), "m_flDefuseCountDown");
}
    