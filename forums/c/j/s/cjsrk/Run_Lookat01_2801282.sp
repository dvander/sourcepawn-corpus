/* Plugin Template generated by Pawn Studio */

#include <sdktools>
#include <sourcemod>
#include <sdkhooks>
#include <cstrike>
#include <halflife>

new Handle:cvarEnable;
new bool:isEnabled;    //启动或禁用插件变量

public Plugin:myinfo = {
	name = "Run LookAt01 Action",
	author = "srk",
	description = "<- Run the LookAt01 Action Of Some Weapons ->",
	version = "1.0",
	url = "<- URL ->"
}

char RLWeaponsName[256][20];    //带检视动作的武器类名数组
int RLWeaponsSequence[256] = {0};    //检视动作的动画序列号
int RLWeaponsActTime[256] = {0};    //检视动作的动画时长
int SecondRLWeaponsSequence[256] = {0};    //第二个检视动作的动画序列号（仅可用于usp、m4a1或父类武器为usp、m4a1）
int SecondRLWeaponsActTime[256] = {0};    //第二个检视动作的动画时长（仅可用于usp、m4a1或父类武器为usp、m4a1）
int IdleWeaponsSequence[256] = {0};    //Idle动作（无消音器）的动画序列号（仅可用于usp、m4a1或父类武器为usp、m4a1）
int SecondIdleWeaponsSequence[256] = {0};     //Idle动作（有消音器）的动画序列号（仅可用于usp、m4a1或父类武器为usp、m4a1）
int WeaponShootActTime[256] = {0};     //射击动作的动画时长（只用于m3、scout、awp，或父类武器为m3、scout、awp的打一发拉一下的枪支）

int BlockTime[128] = {0};    //防止重复按键重复执行函数的数组
int SecondBlockTime[128] = {0};    //防止重复按键重复执行函数的数组（第二个检视动作,仅可用于usp、m4a1或父类武器为usp、m4a1）


public OnPluginStart()
{	
    //设置配置文件
	CreateConVar("sm_run_lookat01_version", "0.0.2", "插件版本", FCVAR_PLUGIN|FCVAR_SPONLY|FCVAR_REPLICATED|FCVAR_NOTIFY);
	cvarEnable = CreateConVar("sm_run_lookat01_enable", "1", "是否启用插件（1：启用；0：禁用）", FCVAR_PLUGIN, true, 0.0, true, 1.0);
	AutoExecConfig(true, "plugin.run_lookat01");
	HookConVarChange(cvarEnable, CvarChange);
	
	RegConsoleCmd("sm_lookat",Cmd_CreateAnaconda);
	HookEvent("round_start", RoundStart2, EventHookMode_Post);
	HookEvent("weapon_fire", WeaponFire2, EventHookMode_Post);
}

public OnMapStart(){	
    //RegConsoleCmd("sm_lookat",Cmd_CreateAnaconda);
	
	//读取新人物信息文件	
	new String:filepath[PLATFORM_MAX_PATH];
	BuildPath(Path_SM, filepath, PLATFORM_MAX_PATH, "configs/WeaponsLookAtAction.txt");
	new Handle:file = OpenFile(filepath, "r"); 
	if(file != INVALID_HANDLE){
		
		decl String:fileline[256];
		decl String:data[8][256];
		static int num = 0;
		
		while(ReadFileLine(file, fileline, 256))
		{		
			if(ExplodeString(fileline, "><", data, 8, 256) == 8)
			{
				if(strlen(data[0]) > 0 && strlen(data[2]) > 0)
				{
					//将带检视动作的武器数据载入各个武器信息数组
					TrimString(data[0]);
					TrimString(data[1]);
					TrimString(data[2]);
					TrimString(data[3]);
					TrimString(data[4]);
					TrimString(data[5]);
					TrimString(data[6]);
					TrimString(data[7]);
					
					if(strlen(data[0]) > 0)
					    ReplaceString(data[0], strlen(data[0]), "<", "");
					if(strlen(data[7]) > 0)
					    ReplaceString(data[7], strlen(data[7]), ">", "");
					
					new TempFlag = true;
					for(int i = 0; i <= (sizeof(RLWeaponsName) - 1); i++) {
						if(StrEqual(RLWeaponsName[i], data[0]))
						{
							TempFlag = false;
							break;
						}
					}
					new WeaponsActTime = 0;
					if(strlen(data[2]) > 0)
					{
						WeaponsActTime = StringToInt(data[2]);
						if(WeaponsActTime <= 0)
							TempFlag == false
					}	
					if(TempFlag == false)
						continue;
					
					strcopy(RLWeaponsName[num], strlen(data[0]) + 1, data[0]);
					
					new WeaponsSequence = 0;
					if(strlen(data[1]) > 0)
						WeaponsSequence = StringToInt(data[1]);
				    RLWeaponsSequence[num] = WeaponsSequence;
					if(RLWeaponsSequence[num] < 0)
						RLWeaponsSequence[num] = 0;
					
				    RLWeaponsActTime[num] = WeaponsActTime;
					
					// 第二个检视动作（仅可用于usp、m4a1或父类武器为usp、m4a1）
					new SecondWeaponsSequence = 0;
					if(strlen(data[3]) > 0)
						SecondWeaponsSequence = StringToInt(data[3]);
				    SecondRLWeaponsSequence[num] = SecondWeaponsSequence;
					if(SecondRLWeaponsSequence[num] < 0)
						SecondRLWeaponsSequence[num] = 0;
					new SecondWeaponsActTime = 0;
				    SecondWeaponsActTime = StringToInt(data[4]);
					if(SecondWeaponsActTime > 0)
						SecondRLWeaponsActTime[num] = SecondWeaponsActTime;
					else
						SecondRLWeaponsActTime[num] = 0;
					
					//Idle动作（无消音器）的动画序列号（仅可用于usp、m4a1或父类武器为usp、m4a1）
					new IdleSequence = 0;
					if(strlen(data[5]) > 0)
						IdleSequence = StringToInt(data[5]);
				    IdleWeaponsSequence[num] = IdleSequence;
					if(IdleWeaponsSequence[num] < 0)
						IdleWeaponsSequence[num] = 0;
					
					//Idle动作（有消音器）的动画序列号（仅可用于usp、m4a1或父类武器为usp、m4a1）
					new SecondIdleSequence = 0;
					if(strlen(data[6]) > 0)
						SecondIdleSequence = StringToInt(data[6]);
				    SecondIdleWeaponsSequence[num] = SecondIdleSequence;
					if(SecondIdleWeaponsSequence[num] < 0)
						SecondIdleWeaponsSequence[num] = 0;
					
					//射击动作动画时长（只用于m3、scout、awp，或父类武器为m3、scout、awp的打一发拉一下的枪支）
					new ShootActTime = 0;
					if(strlen(data[7]) > 0)
						ShootActTime = StringToInt(data[7]);
				    WeaponShootActTime[num] = ShootActTime;
					if(WeaponShootActTime[num] < 0)
						WeaponShootActTime[num] = 0;
					
					num++;
				}
			    				
			}
			
		}	
		
		CloseHandle(file);		
	}
}


public OnClientPutInServer(Client)
{
    SDKHook(Client, SDKHook_WeaponEquipPost, OnWeaponEquip2);
	SDKHook(Client, SDKHook_WeaponSwitchPost, OnWeaponSwitch2);
}

//读取配置文件的cvar的值
public OnConfigsExecuted()
{
	isEnabled = GetConVarBool(cvarEnable);
}

//cvar值变化时的响应数组
public CvarChange(Handle:convar, const String:oldValue[], const String:newValue[])
{
    if(convar == cvarEnable)
	{
		if(StringToInt(newValue) == 1)
		{
			isEnabled = true;
		}
		else
		{
			isEnabled = false;
		}
	}
}

//检测玩家属性函数
bool:IsClient(Client, bool:Alive)
{
	return Client <= MaxClients && IsClientConnected(Client) && IsClientInGame(Client) && (Alive && IsPlayerAlive(Client));
}


//播放检视动作函数
public Action:Cmd_CreateAnaconda(Client,Args){
	if(!Client) Client=1;
	
	if(isEnabled == false)
	{
		PrintToChat(Client, "提示：插件已被禁用，您不能触发武器检视动作！");
		return;
	}
	
	if(IsClient(Client, true) && !IsFakeClient(Client))
	{		
		//找到和用户当前武器类名相匹配的带检视动作武器类名
		new String:s_playerWeapon[32];
		GetClientWeapon(Client, s_playerWeapon, sizeof(s_playerWeapon));
		int num = -1, UspOrM4a1 = 0;
		for(int i = 0; i <= (sizeof(RLWeaponsName) - 1); i++) {
			char PreStr[] = "weapon_";
			char g_WeaponsName[32];
			Format(g_WeaponsName, sizeof(g_WeaponsName), "%s%s", PreStr, RLWeaponsName[i]);
			TrimString(g_WeaponsName);
			if(StrEqual(g_WeaponsName, s_playerWeapon))
			{
				num = i;
				if(StrEqual(g_WeaponsName, "weapon_usp") || StrEqual(g_WeaponsName, "weapon_m4a1"))
					UspOrM4a1 = 1;
				break;
			}
		}
		
		if(num > -1)
		{
			new currentWeapon = GetEntPropEnt(Client, Prop_Send, "m_hActiveWeapon");	
            if (!IsValidEdict(currentWeapon) || (currentWeapon == -1))
		        return;
			if(HasEntProp(currentWeapon, Prop_Send, "m_bSilencerOn") == true && HasEntProp(currentWeapon, Prop_Send, "m_weaponMode") == true)
				UspOrM4a1 = 1;
			
			//判断武器（或其父类武器）是否为usp/m4a1
		    if(UspOrM4a1 == 1)
			{
				if(BlockTime[Client] == 1)
				{
					// PrintToChat(Client, "提示：暂停！");
					return;
				}
				if(SecondBlockTime[Client] == 1)
				{
					// PrintToChat(Client, "提示：暂停！");
					return;
				}
			}
			else
			{
				if(BlockTime[Client] == 1)
				{
					// PrintToChat(Client, "提示：暂停！");
					return;
				}
			}
			
			new ent = GetEntPropEnt(Client, Prop_Send, "m_hViewModel");
            if (!IsValidEdict(ent))
				return;	
			
			//如果武器（或其父类武器）不是usp/m4a1
			if(UspOrM4a1 == 0)
			{
				BlockTime[Client] = 1;	
				SetEntProp(ent, Prop_Send, "m_nSequence", RLWeaponsSequence[num]);    //播放检视动作所在的动画序列，RLWeaponsSequence[num]为序号
			    SetEntPropFloat(ent, Prop_Send, "m_flPlaybackRate", 1.0);
				// SetEntPropFloat(currentWeapon, Prop_Send, "m_flTimeWeaponIdle", float(RLWeaponsActTime[num])); 
			    SetEntPropFloat(currentWeapon, Prop_Data, "m_flTimeWeaponIdle", GetGameTime() + float(RLWeaponsActTime[num]));    //更改下次调用武器空闲动作的时间为检视动作时长（单位：帧）
				float tempNum = RLWeaponsActTime[num]/30.0;
				//PrintToChat(Client, "时长：%f", GetGameTime() + float(RLWeaponsActTime[num]));
				int UspOrM4a1 = 0;
				
				DataPack pack = new DataPack();
				pack.WriteCell(Client);
				pack.WriteCell(currentWeapon);
				pack.WriteCell(ent);
				pack.WriteCell(num);
				pack.WriteCell(UspOrM4a1);
				CreateTimer(tempNum, Timer_RunATimes, pack);    ///防止重复按键和重复执行函数
			}
			
            //如果武器（或其父类武器）是usp/m4a1			
            if(UspOrM4a1 == 1)
			{
				BlockTime[Client] = 1;
				SecondBlockTime[Client] = 1;
				
				//如果武器处于普通状态
				if(GetEntProp(currentWeapon, Prop_Send, "m_bSilencerOn") == 0)
				{
					SetEntProp(ent, Prop_Send, "m_nSequence", RLWeaponsSequence[num]);    //播放检视动作所在的动画序列，RLWeaponsSequence[num]为序号
			        SetEntPropFloat(ent, Prop_Send, "m_flPlaybackRate", 1.0);
					// SetEntPropFloat(currentWeapon, Prop_Send, "m_flTimeWeaponIdle", float(RLWeaponsActTime[num])); 
			        SetEntPropFloat(currentWeapon, Prop_Data, "m_flTimeWeaponIdle", GetGameTime() + float(RLWeaponsActTime[num]));    //更改下次调用武器空闲动作的时间为检视动作时长（单位：帧）
					float tempNum = RLWeaponsActTime[num]/30.0;
					//PrintToChat(Client, "时长：%f", GetGameTime() + float(RLWeaponsActTime[num]));
					int UspOrM4a1 = 1;    //普通状态
					if(SecondRLWeaponsActTime[num] <= 0)    //如果没有第二个检视动作
						UspOrM4a1 = 0;
						
					DataPack pack = new DataPack();
					pack.WriteCell(Client);
					pack.WriteCell(currentWeapon);
					pack.WriteCell(ent);
					pack.WriteCell(num);
					pack.WriteCell(UspOrM4a1);
					CreateTimer(tempNum, Timer_RunATimes, pack);    ///防止重复按键和重复执行函数
				}
				
				//如果武器处于消音状态
				if(GetEntProp(currentWeapon, Prop_Send, "m_bSilencerOn") == 1 && SecondRLWeaponsActTime[num] <= 0)    //如果没有第二个检视动作
				{
					BlockTime[Client] = 0;
				    SecondBlockTime[Client] = 0;
				}
				if(GetEntProp(currentWeapon, Prop_Send, "m_bSilencerOn") == 1 && SecondRLWeaponsActTime[num] > 0)
				{
					SetEntProp(ent, Prop_Send, "m_nSequence", SecondRLWeaponsSequence[num]);    //播放第二个检视动作所在的动画序列，RLWeaponsSequence[num]为序号
			        SetEntPropFloat(ent, Prop_Send, "m_flPlaybackRate", 1.0);
			        SetEntPropFloat(currentWeapon, Prop_Data, "m_flTimeWeaponIdle", GetGameTime() + float(SecondRLWeaponsActTime[num]));    //更改下次调用武器空闲动作的时间为第二个检视动作时长（单位：帧）
					float tempNum = SecondRLWeaponsActTime[num]/30.0;
					//PrintToChat(Client, "时长：%f", GetGameTime() + float(SecondRLWeaponsActTime[num]));
					int UspOrM4a1 = 2;    //消音状态
					
					DataPack pack = new DataPack();
					pack.WriteCell(Client);
					pack.WriteCell(currentWeapon);
					pack.WriteCell(ent);
					pack.WriteCell(num);
					pack.WriteCell(UspOrM4a1);
					CreateTimer(tempNum, Timer_RunATimes, pack);    ///防止重复按键和重复执行函数
				}
			}				
		}
	}
}


///防止重复按键和重复执行函数
public Action:Timer_RunATimes(Handle timer, DataPack pack)
{
	pack.Reset(); 
	int client = pack.ReadCell();
	int weapon = pack.ReadCell();
	int ent = pack.ReadCell();
	int num = pack.ReadCell();
	int UspOrM4a1 = pack.ReadCell();
	CloseHandle(pack);
	
	BlockTime[client] = 0;
	SecondBlockTime[client] = 0;
	
	if(IsValidEdict(weapon) && weapon > -1)
	{
		SetEntPropFloat(weapon, Prop_Data, "m_flTimeWeaponIdle", GetGameTime());
		
		if(IsValidEdict(ent) && ent > -1 && HasEntProp(ent, Prop_Send, "m_nSequence") == true)
		{
			if(IsClient(client, true) && UspOrM4a1 == 1)    //普通状态
			{
				SetEntProp(ent, Prop_Send, "m_nSequence", IdleWeaponsSequence[num]);    //播放Idle动作（无消音器）所在的动画序列
			}
			if(IsClient(client, true) && UspOrM4a1 == 2)    //消音状态
			{
				SetEntProp(ent, Prop_Send, "m_nSequence", SecondIdleWeaponsSequence[num]);    //播放Idle动作（有消音器）所在的动画序列
			}
		}					
	}	    
}


public void:OnWeaponEquip2(client, weapon)
{   
    if (IsClient(client, true) && !IsFakeClient(client)) 
	{
		decl String:sWeapon[32];
		GetEdictClassname(weapon, sWeapon, sizeof(sWeapon));
		int num = -1;
		for(int i = 0; i <= (sizeof(RLWeaponsName) - 1); i++) {
			char PreStr[] = "weapon_";
			char g_WeaponsName[32];
			Format(g_WeaponsName, sizeof(g_WeaponsName), "%s%s", PreStr, RLWeaponsName[i]);
			TrimString(g_WeaponsName);
			if(StrEqual(g_WeaponsName, sWeapon))
			{
				num = i;
				break;
			}
		}
			
		if(num > -1)
		{
			SDKHook(weapon, SDKHook_ReloadPost, OnWeaponReload2);
		}
	}
}


//换弹期间禁止检视
public Action:OnWeaponReload2(weapon)
{
	new client = GetEntPropEnt(weapon, Prop_Send, "m_hOwnerEntity");
    if (IsClient(client, true) && !IsFakeClient(client))
	{
		float ReloadTime = GetEntPropFloat(client, Prop_Send, "m_flNextAttack") - GetGameTime();    //获取换弹时间
		BlockTime[client] = 1;
	    SecondBlockTime[client] = 1;
		CreateTimer(ReloadTime, Timer_RestrictTime, client);    //换弹结束后启用检视
	}
}


//启用检视函数
public Action:Timer_RestrictTime(Handle timer, int client)
{
	if(!IsValidEntity(client))
		return Plugin_Continue;
	if (IsClient(client, true) && !IsFakeClient(client))
	{
		BlockTime[client] = 0;
	    SecondBlockTime[client] = 0;
	}
}


//切换到带检视动作的枪时，禁止检视
public Action:OnWeaponSwitch2(client, weapon)
{
    if (IsClient(client, true) && !IsFakeClient(client)) 
	{
		decl String:sWeapon[32];
		GetEdictClassname(weapon, sWeapon, sizeof(sWeapon));
		int num = -1;
		for(int i = 0; i <= (sizeof(RLWeaponsName) - 1); i++) {
			char PreStr[] = "weapon_";
			char g_WeaponsName[32];
			Format(g_WeaponsName, sizeof(g_WeaponsName), "%s%s", PreStr, RLWeaponsName[i]);
			TrimString(g_WeaponsName);
			if(StrEqual(g_WeaponsName, sWeapon))
			{
				num = i;
				break;
			}
		}
			
		if(num > -1)
		{
			float SwitchTime = GetEntPropFloat(client, Prop_Send, "m_flNextAttack") - GetGameTime();
			BlockTime[client] = 1;
	        SecondBlockTime[client] = 1;
			CreateTimer(SwitchTime, Timer_RestrictTime, client);    //切换动作结束后启用检视
		}
	}
}


//装卸消音器期间禁止检视
public Action:OnPlayerRunCmd(client, &buttons, &impulse, Float:vel[3], Float:angles[3], &weapon)
{
	if ((buttons & IN_ATTACK2))
	{
		if (IsClient(client, true) && !IsFakeClient(client)) 
		{
			new currentWeapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");	
            if (!IsValidEdict(currentWeapon) || (currentWeapon == -1))
		        return;
			decl String:sWeapon[32];
		    GetEdictClassname(currentWeapon, sWeapon, sizeof(sWeapon));
			int num = -1;
			for(int i = 0; i <= (sizeof(RLWeaponsName) - 1); i++) {
				char PreStr[] = "weapon_";
				char g_WeaponsName[32];
				Format(g_WeaponsName, sizeof(g_WeaponsName), "%s%s", PreStr, RLWeaponsName[i]);
				TrimString(g_WeaponsName);
				if(StrEqual(g_WeaponsName, sWeapon))
				{
					num = i;
					break;
				}
			}
			
			if(num > -1)
			{
				if(StrEqual(sWeapon, "weapon_usp") || StrEqual(sWeapon, "weapon_m4a1") || (HasEntProp(currentWeapon, Prop_Send, "m_bSilencerOn") == true && HasEntProp(currentWeapon, Prop_Send, "m_weaponMode") == true))
				{
					BlockTime[client] = 1;
				    SecondBlockTime[client] = 1;
					CreateTimer(2.0, Timer_RestrictTime, client);    //装卸消音器结束后启用检视
				}				
			} 
		}
	}
}


//武器射击时禁止检视
public WeaponFire2(Handle:event,const String:name[],bool:dontBroadcast)
{
	new client = GetClientOfUserId(GetEventInt(event, "userid"));
	if (IsClient(client, true) && !IsFakeClient(client)) 
	{
		//获取当前武器名字
		if(!IsValidEntity(client))
			return;
		if(HasEntProp(client, Prop_Send, "m_hActiveWeapon") == false)
			return;
		new currentWeapon = GetEntPropEnt(client, Prop_Send, "m_hActiveWeapon");
		if (!IsValidEdict(currentWeapon) || (currentWeapon == -1))
			return;	
		decl String:sWeapon[32];
		GetEdictClassname(currentWeapon, sWeapon, sizeof(sWeapon));
		int num = -1;
		for(int i = 0; i <= (sizeof(RLWeaponsName) - 1); i++) {
			char PreStr[] = "weapon_";
			char g_WeaponsName[32];
			Format(g_WeaponsName, sizeof(g_WeaponsName), "%s%s", PreStr, RLWeaponsName[i]);
			TrimString(g_WeaponsName);
			if(StrEqual(g_WeaponsName, sWeapon))
			{
				num = i;
				break;
			}
		}
			
		if(num > -1)
		{
			if(WeaponShootActTime[num] > 0)
			{
				BlockTime[client] = 1;
			    SecondBlockTime[client] = 1;
				float tempNum2 = WeaponShootActTime[num]/30.0;
				// PrintToChat(client, "时长：%f", tempNum2);
				CreateTimer(tempNum2, Timer_RestrictTime, client);    //射击动作结束后启用检视
			}			
		}
	}
}



public Action:RoundStart2(Handle:event, const String:name[], bool:dontBroadcast) {
	if(isEnabled == true)
	{
		for(int i = 0; i <= (sizeof(BlockTime) - 1); i++) {
			BlockTime[i] = 0;
			SecondBlockTime[i] = 0;
		}
	}
}